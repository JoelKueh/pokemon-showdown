{
  "version": 3,
  "sources": ["../../sim/dex-bagitems.ts"],
  "sourcesContent": ["import type { PokemonEventMethods, ConditionData } from './dex-conditions';\nimport { assignMissingFields, BasicEffect, toID } from './dex-data';\nimport { Utils } from '../lib/utils';\n\nexport class BagItem extends BasicEffect implements Readonly<BasicEffect> {\n\tdeclare readonly effectType: 'BagItem';\n\n\t/** just controls location on the item spritesheet */\n\tdeclare readonly num: number;\n\n\t/** Is this item a Pokeball? */\n\treadonly isPokeball: boolean;\n\n\tdeclare readonly condition?: ConditionData;\n\tdeclare readonly forcedForme?: string;\n\tdeclare readonly isChoice?: boolean;\n\tdeclare readonly naturalGift?: { basePower: number, type: string };\n\tdeclare readonly spritenum?: number;\n\tdeclare readonly boosts?: SparseBoostsTable | false;\n\n\tdeclare readonly onUse?: ((this: Battle, pokemon: Pokemon) => void) | false;\n\tdeclare readonly onStart?: (this: Battle, target: Pokemon) => void;\n\tdeclare readonly onEnd?: (this: Battle, target: Pokemon) => void;\n\n\tconstructor(data: AnyObject) {\n\t\tsuper(data);\n\n\t\tthis.fullname = `item: ${this.name}`;\n\t\tthis.effectType = 'BagItem';\n\t\tthis.isPokeball = !!data.isPokeball;\n\n\t\tif (!this.gen) {\n\t\t\tif (this.num >= 1124) {\n\t\t\t\tthis.gen = 9;\n\t\t\t} else if (this.num >= 927) {\n\t\t\t\tthis.gen = 8;\n\t\t\t} else if (this.num >= 689) {\n\t\t\t\tthis.gen = 7;\n\t\t\t} else if (this.num >= 577) {\n\t\t\t\tthis.gen = 6;\n\t\t\t} else if (this.num >= 537) {\n\t\t\t\tthis.gen = 5;\n\t\t\t} else if (this.num >= 377) {\n\t\t\t\tthis.gen = 4;\n\t\t\t} else {\n\t\t\t\tthis.gen = 3;\n\t\t\t}\n\t\t\t// Due to difference in gen 2 item numbering, gen 2 items must be\n\t\t\t// specified manually\n\t\t}\n\n\t\tassignMissingFields(this, data);\n\t}\n}\n\n//export class DexBagItems {\n//\treadonly dex: ModdedDex;\n//\treadonly itemCache = new Map<ID, Item>();\n//\tallCache: readonly Item[] | null = null;\n//\n//\tconstructor(dex: ModdedDex) {\n//\t\tthis.dex = dex;\n//\t}\n//\n//\tget(name?: string | Item): Item {\n//\t\tif (name && typeof name !== 'string') return name;\n//\t\tconst id = name ? toID(name.trim()) : '' as ID;\n//\t\treturn this.getByID(id);\n//\t}\n//\n//\tgetByID(id: ID): Item {\n//\t\tif (id === '') return EMPTY_ITEM;\n//\t\tlet item = this.itemCache.get(id);\n//\t\tif (item) return item;\n//\t\tif (this.dex.getAlias(id)) {\n//\t\t\titem = this.get(this.dex.getAlias(id));\n//\t\t\tif (item.exists) {\n//\t\t\t\tthis.itemCache.set(id, item);\n//\t\t\t}\n//\t\t\treturn item;\n//\t\t}\n//\t\tif (id && !this.dex.data.Items[id] && this.dex.data.Items[id + 'berry']) {\n//\t\t\titem = this.getByID(id + 'berry' as ID);\n//\t\t\tthis.itemCache.set(id, item);\n//\t\t\treturn item;\n//\t\t}\n//\t\tif (id && this.dex.data.Items.hasOwnProperty(id)) {\n//\t\t\tconst itemData = this.dex.data.Items[id] as any;\n//\t\t\tconst itemTextData = this.dex.getDescs('Items', id, itemData);\n//\t\t\titem = new Item({\n//\t\t\t\tname: id,\n//\t\t\t\t...itemData,\n//\t\t\t\t...itemTextData,\n//\t\t\t});\n//\t\t\tif (item.gen > this.dex.gen) {\n//\t\t\t\t(item as any).isNonstandard = 'Future';\n//\t\t\t}\n//\t\t\tif (this.dex.parentMod) {\n//\t\t\t\t// If this item is exactly identical to parentMod's item, reuse parentMod's copy\n//\t\t\t\tconst parent = this.dex.mod(this.dex.parentMod);\n//\t\t\t\tif (itemData === parent.data.Items[id]) {\n//\t\t\t\t\tconst parentItem = parent.items.getByID(id);\n//\t\t\t\t\tif (\n//\t\t\t\t\t\titem.isNonstandard === parentItem.isNonstandard &&\n//\t\t\t\t\t\titem.desc === parentItem.desc &&\n//\t\t\t\t\t\titem.shortDesc === parentItem.shortDesc\n//\t\t\t\t\t) {\n//\t\t\t\t\t\titem = parentItem;\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n//\t\t} else {\n//\t\t\titem = new Item({ name: id, exists: false });\n//\t\t}\n//\n//\t\tif (item.exists) this.itemCache.set(id, this.dex.deepFreeze(item));\n//\t\treturn item;\n//\t}\n//\n//\tall(): readonly Item[] {\n//\t\tif (this.allCache) return this.allCache;\n//\t\tconst items = [];\n//\t\tfor (const id in this.dex.data.Items) {\n//\t\t\titems.push(this.getByID(id as ID));\n//\t\t}\n//\t\tthis.allCache = Object.freeze(items);\n//\t\treturn this.allCache;\n//\t}\n//}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,sBAAuD;AAGhD,MAAM,gBAAgB,4BAA6C;AAAA,EAoBzE,YAAY,MAAiB;AAC5B,UAAM,IAAI;AAEV,SAAK,WAAW,SAAS,KAAK,IAAI;AAClC,SAAK,aAAa;AAClB,SAAK,aAAa,CAAC,CAAC,KAAK;AAEzB,QAAI,CAAC,KAAK,KAAK;AACd,UAAI,KAAK,OAAO,MAAM;AACrB,aAAK,MAAM;AAAA,MACZ,WAAW,KAAK,OAAO,KAAK;AAC3B,aAAK,MAAM;AAAA,MACZ,WAAW,KAAK,OAAO,KAAK;AAC3B,aAAK,MAAM;AAAA,MACZ,WAAW,KAAK,OAAO,KAAK;AAC3B,aAAK,MAAM;AAAA,MACZ,WAAW,KAAK,OAAO,KAAK;AAC3B,aAAK,MAAM;AAAA,MACZ,WAAW,KAAK,OAAO,KAAK;AAC3B,aAAK,MAAM;AAAA,MACZ,OAAO;AACN,aAAK,MAAM;AAAA,MACZ;AAAA,IAGD;AAEA,6CAAoB,MAAM,IAAI;AAAA,EAC/B;AACD;",
  "names": []
}
